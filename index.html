<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Radiology RVU Tally — No-Build Demo</title>

    <!-- Tailwind (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React (UMD) + Babel for inline JSX -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tesseract.js (OCR) -->
    <script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>

    <style>
      .tabular-nums { font-variant-numeric: tabular-nums; }
    </style>
  </head>
  <body class="bg-gray-50 text-gray-900">
    <div id="root"></div>

    <script type="text/babel">
      const { useMemo, useRef, useState, useEffect } = React;

      // CSV helper
      function toCSV(rows) {
        const header = Object.keys(rows[0] || { Study: "", Count: "", RVU: "", Total: "" });
        const lines = [header.join(",")].concat(
          rows.map((r) => header.map((h) => JSON.stringify(r[h] ?? "")).join(","))
        );
        return lines.join("\n");
      }

      // Prefilled starter RVUs (loose patterns—no ^ anchor)
const DEFAULT_RULES = [
  // ========= XRAY (Extremities & Chest/Abdomen) =========
  { label: "XR Hand 3+ Views",
    pattern: "XR\\s*HAND\\b.*(?:3\\s*\\+|3\\+?)\\s*VIEW(?:S)?",
    baseRvu: 0.70 },

  { label: "XR Ankle 3+ Views",
    pattern: "XR\\s*ANKLE\\b.*(?:3\\s*\\+|3\\+?)\\s*VIEW(?:S)?",
    baseRvu: 0.70 },

  { label: "XR Foot 3+ Views",
    pattern: "XR\\s*FOOT\\b.*(?:3\\s*\\+|3\\+?)\\s*VIEW(?:S)?",
    baseRvu: 0.70 },

  { label: "XR Wrist 3+ Views",
    pattern: "XR\\s*WRIST\\b.*(?:3\\s*\\+|3\\+?)\\s*VIEW(?:S)?",
    baseRvu: 0.70 },

  { label: "XR Knee 4+ Views",
    pattern: "XR\\s*KNEE\\b.*(?:4\\s*\\+|4\\+?)\\s*VIEW(?:S)?",
    baseRvu: 0.95 },

  { label: "XR Knee 3 Views",
    pattern: "XR\\s*KNEE\\b.*(?:3\\s*VIEW(?:S)?)",
    baseRvu: 0.70 },

  // Tibia/Fibula 2V (tolerate OCR like XRTBIAFBULA2VIEW)
  { label: "XR Tibia/Fibula 2 Views",
    pattern: "XR\\s*(?:TIBIA\\s*FIBULA|TBIAF?BULA)\\b.*(?:2\\s*VIEW(?:S)?)",
    baseRvu: 0.70 },

  // Chest
  { label: "XR Chest 2 Views (PA/Lateral)",
    pattern: "XR\\s*CHEST\\b.*(?:2\\s*VIEW(?:S)?).*?(?:PA\\s*LAT(?:ERAL)?|PALATERAL|PA\\s*LATERAL)",
    baseRvu: 0.22 },

  { label: "XR Chest 1 View (PA or AP)",
    pattern: "XR\\s*CHEST\\b.*(?:1\\s*VIEW).*?(?:PA|AP|PA\\s*OR\\s*AP)?",
    baseRvu: 0.10 },

  // Abdomen
  { label: "XR Abdomen 1 View (AP)",
    pattern: "XR\\s*ABDOMEN\\b.*(?:1\\s*VIEW).*?(?:AP)?",
    baseRvu: 0.20 },

  // ========= XRAY (Spine & Hips) =========
  { label: "XR L-Spine 4+ Views",
    pattern: "XR\\s*L[-\\s]?SPINE\\b.*(?:4\\s*\\+|4\\+?)\\s*VIEW(?:S)?",
    baseRvu: 1.30 },

  { label: "XR L-Spine 2-3 Views",
    // match '2-3' OR OCR '23'
    pattern: "XR\\s*L[-\\s]?SPINE\\b.*(?:(?:2\\s*-?\\s*3)|23)\\s*VIEW(?:S)?",
    baseRvu: 0.95 },

  { label: "XR T-Spine 3 Views",
    pattern: "XR\\s*T[-\\s]?SPINE\\b.*(?:3\\s*VIEW(?:S)?)",
    baseRvu: 0.95 },

  { label: "XR C-Spine 2-3 Views",
    pattern: "XR\\s*C[-\\s]?SPINE\\b.*(?:(?:2\\s*-?\\s*3)|23)\\s*VIEW(?:S)?",
    baseRvu: 0.95 },

  // Hips & Pelvis variants: XRHIP 23 VIEWS ... W/PELVIS ; XRHP2IVIEWS...
  { label: "XR Hip 2-3 Views w/ Pelvis",
    pattern: "XR\\s*H[IP]\\b.*(?:(?:2\\s*-?\\s*3)|23|2\\s*I)\\s*VIEW(?:S)?\\b.*(?:W\\s*[/]?\\s*|WITH\\s+)PELVI?S",
    baseRvu: 0.90 },

  { label: "XR Hips Bilateral 2+ Views",
    pattern: "XR\\s*HIPS?\\b.*BILATERAL.*(?:2\\s*\\+|2\\+?)\\s*VIEW",
    baseRvu: 1.30 },

  // ========= CT (Head/Neck/Chest/Abdomen/Pelvis/C-spine) =========
  // CT Head without contrast, tolerate WAO, W/O, WO, etc.
  { label: "CT Head W/O Contrast",
    pattern: "CT\\s*HEAD\\b.*W[\\s/]*O\\b.*CONTRAST|CT\\s*HEAD\\b.*\\bW\\s*A?\\s*O\\b.*CONTRAST",
    baseRvu: 2.40 },

  // CTA Head & Neck Stroke
  { label: "CT Angio Head/Neck (Stroke)",
    pattern: "CT\\s*ANGIO\\s*HEAD\\b.*NECK\\b.*STROKE",
    baseRvu: 5.50 },

  // CTA Chest for PE (“CT ANGIO LUNG FOR PULMONARY EM...”)
  { label: "CT Angio Chest (PE protocol)",
    pattern: "CT\\s*ANGIO\\s*(?:CHEST|LUNG)\\b.*(?:PULMONARY\\s*EM|PE)",
    baseRvu: 5.50 },

  // CT Chest W/ Contrast
  { label: "CT Chest w/",
    pattern: "CT\\s*CHEST\\b.*W\\s*[/]?\\s*(?:IV\\s*)?CONT",
    baseRvu: 7.50 },

  // CT Abdomen/Pelvis W/ (tolerate \T\ separators and spacing)
  { label: "CT Abdomen/Pelvis w/ IV Contrast",
    pattern: "CT\\s*ABDOM(?:EN)?\\b.*(?:\\\\?T\\\\?|[/\\\\\\-\\s]+).*PELVI?S\\b.*W\\s*[/]?\\s*(?:IV\\s*)?CONT",
    baseRvu: 12.00 },

  // CT Abdomen/Pelvis W/O
  { label: "CT Abdomen/Pelvis w/o Contrast",
    pattern: "CT\\s*ABDOM(?:EN)?\\b.*(?:\\\\?T\\\\?|[/\\\\\\-\\s]+).*PELVI?S\\b.*W[\\s/]*O\\b",
    baseRvu: 9.00 },

  // CT C-Spine with/without variants (e.g., "CTCSPINEW/O CONTRAST")
  { label: "CT C-Spine w/o Contrast",
    pattern: "CT\\s*C[-\\s]?SPINE\\b.*W[\\s/]*O\\b.*CONTRAST",
    baseRvu: 3.00 },

  { label: "CT C-Spine w/ Contrast",
    pattern: "CT\\s*C[-\\s]?SPINE\\b.*W\\s*[/]?\\s*(?:IV\\s*)?CONTRAST",
    baseRvu: 3.50 },

  // ========= Ultrasound =========
  { label: "US Abdomen Limited",
    pattern: "(?:US|ULTRASOUND)\\b.*ABDOMEN\\b.*LIMITED",
    baseRvu: 0.70 },

  { label: "US Retroperitoneal",
    pattern: "(?:US|ULTRASOUND)\\s*RETROPERITONEAL",
    baseRvu: 0.70 },

  { label: "US OB Transvaginal",
    pattern: "(?:US|ULTRASOUND)\\b.*(?:OB|OBSTETRIC)\\b.*TRANS\\s*VAGINAL|USOBTRANSVAGINAL",
    baseRvu: 1.20 },

  { label: "US Testicular with Doppler",
    pattern: "(?:US|ULTRASOUND)\\b.*TESTICULAR.*DOPPLER",
    baseRvu: 2.00 },

  // ========= Vascular (Duplex) =========
  { label: "Venous Duplex Lower Extremity",
    pattern: "VA[SC]\\b.*DUPLEX.*V?ENOUS.*LOWER\\b",
    baseRvu: 2.60 },

  { label: "Carotid Duplex Bilateral",
    pattern: "VA[SC]\\b.*DUPLEX.*ARTERIAL.*CAROTID.*BILAT",
    baseRvu: 2.30 },
];

      function StudyRow({ name, count, rvu, onRvuChange }) {
        const total = (Number(rvu) || 0) * (count || 0);
        return (
          <div className="grid grid-cols-12 gap-2 items-center py-2 border-b">
            <div className="col-span-6 font-medium truncate" title={name}>{name}</div>
            <div className="col-span-2 text-center">{count}</div>
            <div className="col-span-2">
              <input
                type="number"
                step="0.01"
                className="w-full border rounded-xl px-3 py-1"
                value={rvu ?? 0}
                onChange={(e) => onRvuChange(Number(e.target.value) || 0)}
              />
            </div>
            <div className="col-span-2 text-right tabular-nums">{total.toFixed(2)}</div>
          </div>
        );
      }

      function App() {
        const [rules, setRules] = useState(DEFAULT_RULES.map((r) => ({ ...r })));
        const [image, setImage] = useState(null);
        const [ocrText, setOcrText] = useState("");
        const [progress, setProgress] = useState(null);
        const [counts, setCounts] = useState({});
        const [procLines, setProcLines] = useState([]); // stores extracted procedure lines
        const fileRef = useRef(null);

        const handleFile = (file) => {
          if (!file) return;
          setImage(URL.createObjectURL(file));
          setProgress(0);
          window.Tesseract.recognize(file, "eng", {
            logger: (m) => {
              if (m.status === "recognizing text" && m.progress != null) {
                setProgress(Math.round(m.progress * 100));
              }
            },
          }).then(({ data: { text } }) => {
            setOcrText(text || "");
            setProgress(null);
          }).catch(err => {
            setProgress(null);
            alert("OCR error: " + err.message);
            console.error(err);
          });
        };

        const handleDrop = (e) => {
          e.preventDefault();
          const file = e.dataTransfer.files?.[0];
          handleFile(file);
        };

        // Classifier: broader modality detector + normalization
        const classify = (rawLines) => {
          // Include common variants (XR/X-RAY/RADIOGRAPH, US/ULTRASOUND, VAS/VASCULAR; add CT/CTA/MRI/MRA for robustness)
          const modalityRegex = /\b(XR|X[-\s]?RAY|RADIOGRAPH|CT|CTA|MRI|MRA|US|ULTRASOUND|VAS|VASCULAR)\b/i;

          const normalize = (s) => s
            .toUpperCase()
            .replace(/X[-\s]?RAY/g, "XR")
            .replace(/RADIOGRAPH(?:S|Y)?/g, "XR")
            .replace(/ULTRASOUND/g, "US")
            .replace(/\s+/g, " ")
            .trim();

          const picked = [];

          for (const l of rawLines) {
            const L = normalize(l);
            const m = L.match(modalityRegex);
            if (!m) continue;

            // Take text starting at the first modality token
            const start = m.index ?? 0;
            const fromModality = L.slice(start).trim();

            // Skip very short fragments
            if (fromModality.length < 5) continue;

            picked.push(fromModality);
          }

          // Count matches against rules
          const newCounts = {};
          for (const pl of picked) {
            const rule = rules.find((r) => new RegExp(r.pattern, "i").test(pl));
            const key = rule ? rule.label : `❓ Unclassified: ${pl}`;
            newCounts[key] = (newCounts[key] || 0) + 1;
          }

          setProcLines(picked);
          setCounts(newCounts);
        };

        // Re-run classification whenever OCR text or rules change
        useEffect(() => {
          if (!ocrText) {
            setCounts({});
            setProcLines([]);
            return;
          }
          const lines = ocrText.split(/\n+/).map(s => s.trim()).filter(Boolean);
          classify(lines);
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [ocrText, rules]);

        const totalRVU = useMemo(() => {
          return Object.entries(counts).reduce((acc, [k, c]) => {
            const rule = rules.find((r) => r.label === k);
            const rvu = rule?.baseRvu || 0;
            return acc + rvu * c;
          }, 0);
        }, [counts, rules]);

        const rows = useMemo(() => {
          return Object.entries(counts).map(([name, count]) => {
            const rule = rules.find((r) => r.label === name);
            return { name, count, rvu: rule?.baseRvu ?? 0 };
          });
        }, [counts, rules]);

        const updateRVU = (label, val) => {
          setRules((prev) => prev.map((r) => (r.label === label ? { ...r, baseRvu: val } : r)));
        };

        const addRule = () => {
          setRules((prev) => [
            ...prev,
            { label: "New Rule", pattern: "XR .*", baseRvu: 0 },
          ]);
        };

        const exportCSV = () => {
          const data = rows.map((r) => ({
            Study: r.name, Count: r.count, RVU: r.rvu,
            Total: (r.rvu * r.count).toFixed(2)
          }));
          const csv = toCSV(data);
          const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "rvu_tally.csv";
          a.click();
          URL.revokeObjectURL(url);
        };

        return (
          <div className="min-h-screen p-6">
            <div className="max-w-6xl mx-auto space-y-6">
              <header className="flex items-center justify-between">
                <div>
                  <h1 className="text-2xl font-bold">Radiology RVU Tally</h1>
                  <p className="text-sm text-gray-600">Upload a PowerScribe screenshot → OCR → counts → RVUs.</p>
                </div>
                <div className="flex gap-2">
                  <button onClick={() => fileRef.current?.click()} className="px-4 py-2 rounded-2xl bg-white shadow border">Upload Image</button>
                  <button onClick={exportCSV} className="px-4 py-2 rounded-2xl bg-white shadow border">Export CSV</button>
                </div>
              </header>

              <input
                ref={fileRef}
                type="file"
                accept="image/*,.png,.jpg,.jpeg"
                className="hidden"
                onChange={(e) => handleFile(e.target.files?.[0])}
              />

              <div
                onDragOver={(e) => e.preventDefault()}
                onDrop={handleDrop}
                className="grid grid-cols-1 lg:grid-cols-2 gap-6"
              >
                <div className="bg-white rounded-2xl shadow p-4 min-h-[300px] flex items-center justify-center overflow-hidden">
                  {image ? (
                    <img src={image} alt="uploaded" className="max-h-[420px] rounded-xl" />
                  ) : (
                    <div className="text-center">
                      <div className="text-lg font-medium">Drag & drop your screenshot here</div>
                      <div className="text-sm text-gray-600">or click “Upload Image”</div>
                    </div>
                  )}
                </div>

                <div className="bg-white rounded-2xl shadow p-4">
                  <div className="flex items-center gap-3">
                    <div className="text-sm font-semibold">OCR</div>
                    {progress != null && (
                      <div className="w-full h-2 bg-gray-200 rounded-xl overflow-hidden">
                        <div className="h-2 bg-gray-800" style={{ width: `${progress}%` }} />
                      </div>
                    )}
                  </div>
                  <pre className="mt-3 max-h-[420px] overflow-auto text-xs bg-gray-50 p-3 rounded-xl whitespace-pre-wrap">
                    {ocrText || "(text will appear here after OCR)"}
                  </pre>

                  {/* Debug helper to see what we think are procedure lines */}
                  <div className="mt-3 text-xs">
                    <div className="font-semibold mb-1">Detected procedure lines</div>
                    <ul className="list-disc ml-5 max-h-40 overflow-auto">
                      {procLines.length === 0 ? (
                        <li className="text-gray-500">None detected yet</li>
                      ) : (
                        procLines.map((l, i) => (
                          <li key={i}>{l}</li>
                        ))
                      )}
                    </ul>
                  </div>
                </div>
              </div>

              <section className="bg-white rounded-2xl shadow p-4">
                <div className="flex items-end justify-between mb-4">
                  <div>
                    <h2 className="text-xl font-semibold">Study Counts & RVUs</h2>
                    <p className="text-sm text-gray-600">Edit RVUs as needed. Totals update live.</p>
                  </div>
                  <div className="text-right">
                    <div className="text-sm text-gray-500">Total RVUs</div>
                    <div className="text-2xl font-bold tabular-nums">{totalRVU.toFixed(2)}</div>
                  </div>
                </div>

                <div className="grid grid-cols-12 gap-2 text-xs font-semibold text-gray-600 uppercase tracking-wide">
                  <div className="col-span-6">Study</div>
                  <div className="col-span-2 text-center">Count</div>
                  <div className="col-span-2">RVU</div>
                  <div className="col-span-2 text-right">Total</div>
                </div>

                <div className="divide-y">
                  {rows.length === 0 ? (
                    <div className="text-sm text-gray-500 py-8 text-center">
                      No studies detected yet. Upload a screenshot to begin.
                    </div>
                  ) : (
                    rows.map((r) => (
                      <StudyRow
                        key={r.name}
                        name={r.name}
                        count={r.count}
                        rvu={r.rvu}
                        onRvuChange={(val) => updateRVU(r.name, val)}
                      />
                    ))
                  )}
                </div>
              </section>

              <section className="bg-white rounded-2xl shadow p-4">
                <div className="flex items-center justify-between mb-3">
                  <h3 className="text-lg font-semibold">Classification Rules</h3>
                  <button onClick={addRule} className="px-3 py-1.5 rounded-xl bg-white shadow border">Add Rule</button>
                </div>
                <p className="text-sm text-gray-600 mb-4">
                  OCR lines (even with timestamps/patient info) are trimmed to the first modality token (XR/CT/US/VAS/etc.), then matched top→bottom against these regex patterns.
                </p>
                <div className="overflow-auto">
                  <table className="w-full text-sm">
                    <thead>
                      <tr className="text-left text-gray-600">
                        <th className="p-2">Label</th>
                        <th className="p-2">Regex Pattern</th>
                        <th className="p-2 w-24">Base RVU</th>
                        <th className="p-2 w-20"></th>
                      </tr>
                    </thead>
                    <tbody>
                      {rules.map((r, idx) => (
                        <tr key={idx} className="border-t">
                          <td className="p-2">
                            <input
                              className="w-full border rounded-xl px-2 py-1"
                              value={r.label}
                              onChange={(e) =>
                                setRules((prev) =>
                                  prev.map((x, i) => (i === idx ? { ...x, label: e.target.value } : x))
                                )
                              }
                            />
                          </td>
                          <td className="p-2">
                            <input
                              className="w-full border rounded-xl px-2 py-1 font-mono"
                              value={r.pattern}
                              onChange={(e) =>
                                setRules((prev) =>
                                  prev.map((x, i) => (i === idx ? { ...x, pattern: e.target.value } : x))
                                )
                              }
                            />
                          </td>
                          <td className="p-2">
                            <input
                              type="number"
                              step="0.01"
                              className="w-full border rounded-xl px-2 py-1"
                              value={r.baseRvu}
                              onChange={(e) =>
                                setRules((prev) =>
                                  prev.map((x, i) => (i === idx ? { ...x, baseRvu: Number(e.target.value) || 0 } : x))
                                )
                              }
                            />
                          </td>
                          <td className="p-2 text-right">
                            <button
                              className="px-2 py-1 text-xs rounded-lg border"
                              onClick={() => setRules((prev) => prev.filter((_, i) => i !== idx))}
                            >
                              Remove
                            </button>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </section>

              <footer className="text-center text-xs text-gray-500 py-4">
                Built with client-side OCR (Tesseract.js). No images leave your browser.
              </footer>
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
